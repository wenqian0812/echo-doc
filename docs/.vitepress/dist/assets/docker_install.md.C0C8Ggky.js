import{_ as s,c as a,o as i,a2 as e}from"./chunks/framework.mlmjWbz3.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docker/install.md","filePath":"docker/install.md"}'),t={name:"docker/install.md"},p=e(`<h2 id="安装" tabindex="-1">安装 <a class="header-anchor" href="#安装" aria-label="Permalink to &quot;安装&quot;">​</a></h2><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">curl</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -fsSL</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> https://get.docker.com </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bash</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -s</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> docker --mirror Aliyun</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">deb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [arch=arm64] https://mirrors.aliyun.com/docker-ce/linux/debian buster stable</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot; &gt; /etc/apt/sources.list.d/docker.list</span></span></code></pre></div><h2 id="加速器" tabindex="-1">加速器 <a class="header-anchor" href="#加速器" aria-label="Permalink to &quot;加速器&quot;">​</a></h2><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">curl</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -fsSL</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> https://get.docker.com </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bash</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -s</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> docker --mirror Aliyun</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> systemctl enable docker</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> mkdir -p /etc/docker</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tee /etc/docker/daemon.json </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">EOF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&#39;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">{</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;registry-mirrors&quot;: [&quot;https://2r522sjx.mirror.aliyuncs.com&quot;],</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;log-driver&quot;:&quot;json-file&quot;,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;log-opts&quot;: {&quot;max-size&quot;:&quot;1024m&quot;}</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">EOF</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> systemctl daemon-reload</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> systemctl restart docker</span></span></code></pre></div><h2 id="迁移方案" tabindex="-1">迁移方案 <a class="header-anchor" href="#迁移方案" aria-label="Permalink to &quot;迁移方案&quot;">​</a></h2><p>两种方法迁移 Docker 的默认安装(存储)目录 如果是通过 Ubuntu 的 apt-get 安装的 Docker，默认的安装目录应该是：/var/lib/docker。</p><p>为了完全确定，可以使用以下的命令查询真正的安装路径：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>sudo docker info | grep &quot;Docker Root Dir&quot;</span></span></code></pre></div><p>前置工作 下文以 /store/software/docker 这个路径作为要迁移的新 Docker 安装(存储)目录</p><p>在开始迁移之前，首先复制原 Docker 安装(存储)目录到新的路径下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>cp -a /var/lib/docker /store/software/</span></span></code></pre></div><p>然后备份原目录数据：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>mv -u /var/lib/docker /var/lib/docker.bak</span></span></code></pre></div><h3 id="方法一-软链接" tabindex="-1">方法一：软链接 <a class="header-anchor" href="#方法一-软链接" aria-label="Permalink to &quot;方法一：软链接&quot;">​</a></h3><p>通过把 Docker 的原安装(存储)目录移动到自定义的其他路径下，然后在原位置下建立软链接是最简单快捷的方式。</p><p>首先，关停 Docker 服务：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>sudo systemctl stop docker</span></span>
<span class="line"><span># or</span></span>
<span class="line"><span>sudo service docker stop</span></span></code></pre></div><p>接着，新建一个 /var/lib/docker 的软链：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>sudo ln -fs /store/software/docker /var/lib/docker</span></span></code></pre></div><p>最后，重启 Docker 服务：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>sudo systemctl start docker</span></span>
<span class="line"><span># or</span></span>
<span class="line"><span>sudo service docker start</span></span></code></pre></div><p>启动 Docker 之后，以后你 pull image 和 run container，Docker 写入的路径依然是 /var/lib/docker，但是因为软链的设置，实际已经是往新的目录写入了。至此，完成了 Docker 安装(存储) 目录的迁移。</p><h3 id="方法二-直接修改-docker-配置文件" tabindex="-1">方法二：直接修改 Docker 配置文件 <a class="header-anchor" href="#方法二-直接修改-docker-配置文件" aria-label="Permalink to &quot;方法二：直接修改 Docker 配置文件&quot;">​</a></h3><p>Docker 版本 &lt; v17.05.0 因为 dockerd 运行 Docker 服务的时候可以通过参数 graph 指定镜像和容器存放路径，比如：–graph=/var/lib/docker，我们只需要修改配置文件指定启动参数即可。</p><p>Docker 的配置文件可以设置大部分的后台进程参数，在各个操作系统中的存放位置不一致，在 Ubuntu 中的位置是：/etc/default/docker，在 CentOS 中的位置是：/etc/sysconfig/docker。</p><ul><li><p>如果是 CentOS 则添加下面这行： OPTIONS=--graph=&quot;/store/software/docker&quot; --selinux-enabled -H fd://</p></li><li><p>如果是 Ubuntu 则添加下面这行（因为 Ubuntu 默认没开启 selinux）： OPTIONS=--graph=&quot;/store/software/docker&quot; -H fd://</p></li><li><p>或者 DOCKER_OPTS=&quot;-g /store/software/docker&quot; Docker 版本 &gt;= v17.05.0 因为 Docker 官方在这个发行版本就 deprecated 了 graph 这个 feature，所以如果你机器上安装的 Docker 版本 &gt;= v17.05.0，则无法通过在 /etc/default/docker 配置文件中指定 graph 参数来修改 Docker 的默认安装(存储)目录了，具体参见官网文档：Docker Docs。</p></li></ul><p>好在天无绝人之路，新版本的 Docker 还有其他方式可以达到我们修改安装(存储)目录的目的：通过修改(新建)/etc/docker/daemon.json，指定 data-root 参数的值。</p><p>按如下操作：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>vim /etc/docker/daemon.json</span></span></code></pre></div><p>加入</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>{</span></span>
<span class="line"><span>    &quot;data-root&quot;: &quot;/store/software/docker&quot;,</span></span>
<span class="line"><span>    &quot;storage-driver&quot;: &quot;overlay2&quot; # 这个是 Docker 是默认设置，这里也可以不用加</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>重启 Docker &amp; 清理原安装(存储)目录 最后，重启 Docker 服务：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>sudo systemctl restart docker</span></span>
<span class="line"><span># or</span></span>
<span class="line"><span>sudo service docker restart</span></span></code></pre></div><p>通过上述任一方法完成迁移之后，在确认 Docker 能正常工作之后，删除备份的原目录数据：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rm</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -rf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /var/lib/docker.bak</span></span></code></pre></div><h3 id="迁移方案参考链接" tabindex="-1">迁移方案参考链接 <a class="header-anchor" href="#迁移方案参考链接" aria-label="Permalink to &quot;迁移方案参考链接&quot;">​</a></h3><p><a href="https://ld246.com/article/1566017283738" target="_blank" rel="noreferrer">https://ld246.com/article/1566017283738</a></p><h2 id="docker镜像的导入导出" tabindex="-1">docker镜像的导入导出 <a class="header-anchor" href="#docker镜像的导入导出" aria-label="Permalink to &quot;docker镜像的导入导出&quot;">​</a></h2><p>一、使用 export 和 import 1，查看本机的容器 这两个命令是通过容器来导入、导出镜像。首先我们使用 docker ps -a 命令查看本机所有的容器。</p><p>2，导出镜像 （1）使用 docker export 命令根据容器 ID 将镜像导出成一个文件。</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> export f299f501774c</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> hangger_server.tar</span></span></code></pre></div><p>（2）上面命令执行后，可以看到文件已经保存到当前的 docker 终端目录下。</p><p>3，导入镜像 （1）使用 docker import 命令则可将这个镜像文件导入进来。</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> import - new_hangger_server </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> hangger_server.tar</span></span></code></pre></div><p>（2）执行 docker images 命令可以看到镜像确实已经导入进来了。</p><p>二、使用 save 和 load</p><p>1，查看本机的容器 这两个命令是通过镜像来保存、加载镜像文件的。首先我们使用 docker images 命令查看本机所有的镜像。</p><p>2，保存镜像</p><p>（1）下面使用 docker save 命令根据 ID 将镜像保存成一个文件。</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> save </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">fdf2b4c26d3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> hangge_server.tar</span></span></code></pre></div><p>（2）我们还可以同时将多个 image 打包成一个文件，比如下面将镜像库中的 postgres 和 mongo 打包：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> save -o images.tar postgres:9.6 mongo:3.4</span></span></code></pre></div><p>3，载入镜像 使用 docker load 命令则可将这个镜像文件载入进来。</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> load </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> hangge_server.tar</span></span></code></pre></div><p>附：两种方案的差别 特别注意：两种方法不可混用。 如果使用 import 导入 save 产生的文件，虽然导入不提示错误，但是启动容器时会提示失败，会出现类似&quot;docker: Error response from daemon: Container command not found or does not exist&quot;的错误。</p><p>1，文件大小不同</p><p>export 导出的镜像文件体积小于 save 保存的镜像</p><p>是否可以对镜像重命名</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> import 可以为镜像指定新名称</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> load 不能对载入的镜像重命名</span></span></code></pre></div><p>3，是否可以同时将多个镜像打包到一个文件中</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> export 不支持</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> save 支持</span></span></code></pre></div><p>4，是否包含镜像历史</p><p>export 导出（import 导入）是根据容器拿到的镜像，再导入时会丢失镜像所有的历史记录和元数据信息（即仅保存容器当时的快照状态），所以无法进行回滚操作。 而 save 保存（load 加载）的镜像，没有丢失镜像的历史，可以回滚到之前的层（layer）。</p><p>5，应用场景不同</p><p>docker export 的应用场景：</p><blockquote><p>主要用来制作基础镜像，比如我们从一个 ubuntu 镜像启动一个容器，然后安装一些软件和进行一些设置后，使用 docker export 保存为一个基础镜像。然后，把这个镜像分发给其他人使用，比如作为基础的开发环境。</p></blockquote><p>docker save 的应用场景：</p><blockquote><p>如果我们的应用是使用 docker-compose.yml 编排的多个镜像组合，但我们要部署的客户服务器并不能连外网。这时就</p></blockquote>`,68),n=[p];function l(o,h,r,k,d,c){return i(),a("div",null,n)}const F=s(t,[["render",l]]);export{u as __pageData,F as default};
